# 存储器性能评价指标

## 存储器停顿周期数

存储器的性能直接影响到CPU的性能评价，定义存储器停顿周期数为CPU等待存储器访问而停顿的时钟周期数，由此有CPU执行时间有：
$$
CPU执行时间=(CPU时钟周期数+存储器停顿时钟周期数) \times 时钟周期时间
$$
因此需要存储器停顿时钟周期数越小越好，对于这一变量有公式如下：
$$
存储器停顿周期数 = 缺失数量 \times 缺失代价 = 指令数 \times \frac{产生缺失指令数量}{指令数} \times 缺失代价 \\ = 指令数 \times \frac{存储器访问指令数}{指令总数} \times 缺失率 \times 缺失代价
$$
其中，缺失率表示存储器访问指令中会产生cache缺失的百分比；缺失代价表示发生cache缺失后为了解决缺失需要消耗的平均时钟周期数。另一种度量指标与时钟周期无关，即为每条指令的平均缺失数：
$$
平均缺失数=\frac{产生访存缺失的指令数}{指令总数} = 缺失率 \times \frac{存储器访问指令数}{指令总数}
$$
上述公式与缺失代价无关，缺失率的定义与上文相同

## 存储器平均访问时间

缓存性能比较好的度量为存储器平均访问时间，即对于每次存储器访问而言需要的平均时间，公式如下：
$$
存储器平均访问时间 = 命中时间 + 缺失时间 \times 缺失代价
$$
需要注意的是这一指标仅针对存储器访问指令，因此这是一个间接度量，考虑以下情况：

| 参数                               | 数据  |
| ---------------------------------- | ----- |
| 16KB指令缓存缺失数（每千条指令）   | 3.82  |
| 16KB数据缓存缺失数（每千条指令）   | 40.9  |
| 32KB统一缓存缺失数（每千条指令）   | 43.3  |
| 统一缓存数据访问额外需要时钟周期数 | 1     |
| 存储器访问中指令引用占比           | 74%   |
| 命中周期数/缺失代价                | 1/100 |
| 指令中数据传输指令占比             | 36%   |

需要复习的是，缺失数指的是对于所有指令而言产生存储器缺失的次数，而缺失率为相对于所有存储器访问产生缺失的比例。对于16KB的指令缓存，每条指令都会产生一次指令访问，缺失率为：
$$
缺失率_{指令} = \frac{3.82}{1000 \times 1} = 0.004
$$
对于16KB的数据缓存，有36%的指令会产生一次存储器访问，因此有：
$$
缺失率_{数据} = \frac{40.9 }{0.36 \times 1000} = 0.114
$$
有74%的存储器访问为指令访问，因此总体的缺失率为：
$$
缺失率_{分裂} = 0.74 \times 0.004 + 0.26 \times 0.114 = 0.0326
$$
考虑存储器平均访问时间，有：
$$
存储器平均访问时间_{分裂} = 0.74 \times (1+0.004 \times 200) + 0.26 \times (1 + 0.114\times 200) = 7.52
$$
对于32KB统一缓存而言，1000条指令一共产生1000次指令访存，其中36%的指令会产生数据访存，如下所示：
$$
缺失率_{统一} = \frac{43.3}{1000 + 1000 \times 0.36} = 0.0318
$$
对于统一缓存而言，数据访存指令会产生两种存储器访问，一次指令访问和一次数据访问，而统一缓存仅有端口，因此数据访问需要等待一个时钟周期，因此存储器平均访问时间：
$$
存储器平均访问时间_{统一} = 0.74 \times (1+0.0318 \times 200) + 0.26 \times (1 + 1 + 0.0318 \times 200) = 7.62
$$

## 对CPU性能影响

对于CPU性能而言，有以下公式：
$$
CPU执行时间=(CPU时钟周期数+存储器停顿时钟周期数) \times 时钟周期时间
$$
一般认为缓存命中时间作为CPU执行时钟周期数的一个部分，考虑一个以下参数的缓存：

| 参数                       | 数值 |
| -------------------------- | ---- |
| CPU执行周期数              | 1    |
| 缺失代价                   | 200  |
| 平均缺失率                 | 2%   |
| 每条指令的存储器引用数     | 1.5  |
| 平均缓存缺失数（千条指令） | 30   |

对于以上参数，每千条指令产生的存储访问数为$1000 \times 1.5 = 150$，存储器访问的缺失率为2%，即千条指令产生的存储器缺失数量为$150 \times 2\%=30$，与给出的平均缓存缺失数一致。使用缺失数计算CPU执行时间：
$$
CPU执行时间 = IC \times (1 + \frac{存储器停顿周期数}{IC}) \times 时钟周期 \\= IC \times (1 + \frac{停顿数}{IC} \times 缺失代价) \times 时钟周期 = IC \times (1+\frac{30}{1000} \times 200) \times 时钟周期 \\ = 7 \times IC \times 时钟周期
$$
上述分析均对于顺序存储器而言，其每次存储器缺失都会暴露为缺失代价。对于乱序处理器而言，其存储器缺失可能被乱序执行的其他指令掩盖，即有：
$$
存储器停顿周期 = 缺失数 \times (总缺失代价 - 重叠缺失延迟)
$$
对于乱序执行的CPU而言，分析比较复杂，若一个时钟周期该CPU没有提交最大可能数目的指令，则认为该CPU发生的了存储器访问缺失。

# 存储器层次结构

存储器之间的关于存储器层次结构，需要解决以下四个问题：

- 块的放置：一个块可以放在这一级的什么位置
- 块的识别：如何找到放置在这一级中的一个块
- 块的替换：在缺失时应当替换哪个块
- 块的写入：写入时发生什么

## 块的放置

首先定义**组**的概念，一个组是存储器中的一段连续空间，可以容纳多个（整数个）块。取一个存储器中组的数量为m，每个组可以容纳的块的数量为n，有以下关系：
$$
存储器容量 = m \times n \times 块大小
$$
任何来自某个地址的块只能被放置在一个特定的组中，这种方法被称为组相联，一个组中可以容纳n个块，即为n-路组相联。块首先被映射到组，组编号为：
$$
组编号 = 块地址 \% m 
$$
随后，这个块可以被放置在这个组中的任意块地址位置。即对于一个块地址为A的块而言，对应的组编号为$G = A\%m$，其可以被放置在这个编号为G的组中的任意有效的块起始地址位置。如下图所示：

![](./ch2_cache_group.png)

对于组相联，有两种特殊情况：

- 直接映射：每个块只能存储在一个固定的位置，有$存储地址=块地址 \% m$，可认为时n=1的1-组相联
- 全相联：一个块可以放置在任意位置，可认为时m=1的n-路组相联（缓存中仅有一个组）

## 块的识别

块的识别通过标签识别实现，每个存储器中的块对应一个标签，标签中包括一部分地址信息和有效性信号。对于一个块中的一个数据而言，其地址分为以下几个部分：

- 标志部分：地址的高位部分，判断块时需要比对的部分
- 索引部分：地址的中间部分，标记这个块若存在于存储器中，应当存在于哪个组中，这个部分不用于判断
- 块偏移：地址的低位部分，标记这个数据相对于块起始地址的偏移量

识别块时，首先根据索引部分查找到对应的组，再对比组内所有块的标志部分和要查找的块的标签部分是否相同，同时判断有效性。若标志部分相同且有效，则这个块为待识别的块，否则无识别的块，过程如下所示：

![](./ch2_cache_hit.png)

首先提供查找地址，根据其中的索引查找到可能保存这个块的组，随后比对组内的所有标志和有效位，当有有效位置高且标志匹配的块，则命中，查找到该块。对于要查找的数据，根据偏移量从块中获取数据。

## 块的替换

当块发生缺失且对应的组中没有空闲的位置时，需要从已有的块中选择一个丢弃，块的替换算法决定丢弃哪个块，替换算法有以下几种：

- 随机：随机选择一个块丢弃
- 最近最少使用（LRU）：丢弃掉未使用时间最久的块
- 先入先出（FIFO）：丢弃掉进入存储器最久的块

最近最少使用算法的记录比较困难，常见的替换方法为伪LRU算法，为每一个块设置一个bit。每次对一个块的访问会使这个bit置位为1，当一次访问后所有的bit均为高时，所有bit拉低，仅当前访问的块对应的bit拉高。当需要替换块时，随机从该bit为低的块中选择一个替换

## 块的写入

 块的写入和读取最大的差别在于读取操作可以“任意进行”，因为对任何空间的读取不会对该该空间中的数据产生影响，而写入操作必须“精准执行”，因为写入操作对存储空间中的数据产生影响。对于这一级存储器中任何一个块的写入会产生一致性问题，即当前级的数据与上一级的数据不同，为了解决这一问题，有两种解决方法：

- 直写：写入这一级存储的同时写入上一级存储
- 写回：仅写入这一级存储，当被写入的块被替换时写回上一级存储器

直写策略容易实现，能保证数据的一致性，这上一级存储器中的数据永远时清洁的（即一致的），缺点是时间消耗大。而写回策略延迟低，但是实现复杂。当写回上一级存储器时，往往先将块放入写入缓冲器以减小延迟。另外，当需要对一个地址进行写入时，可能这个地址对应的块不在这一级存储器中，有两种策略：

- 写入分派：首先执行命中操作，将块调入缓存，再进行写入
- 无写入分派：不将对应块调入，直接写入上一级存储器，直写策略下常常使用

## 举例：Opteron缓存

 