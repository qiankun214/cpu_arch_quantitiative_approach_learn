# 存储器性能评价指标

## 存储器停顿周期数

存储器的性能直接影响到CPU的性能评价，定义存储器停顿周期数为CPU等待存储器访问而停顿的时钟周期数，由此有CPU执行时间有：
$$
CPU执行时间=(CPU时钟周期数+存储器停顿时钟周期数) \times 时钟周期时间
$$
因此需要存储器停顿时钟周期数越小越好，对于这一变量有公式如下：
$$
存储器停顿周期数 = 缺失数量 \times 缺失代价 = 指令数 \times \frac{产生缺失指令数量}{指令数} \times 缺失代价 \\ = 指令数 \times \frac{存储器访问指令数}{指令总数} \times 缺失率 \times 缺失代价
$$
其中，缺失率表示存储器访问指令中会产生cache缺失的百分比；缺失代价表示发生cache缺失后为了解决缺失需要消耗的平均时钟周期数。另一种度量指标与时钟周期无关，即为每条指令的平均缺失数：
$$
平均缺失数=\frac{产生访存缺失的指令数}{指令总数} = 缺失率 \times \frac{存储器访问指令数}{指令总数}
$$
上述公式与缺失代价无关，缺失率的定义与上文相同

## 存储器平均访问时间

缓存性能比较好的度量为存储器平均访问时间，即对于每次存储器访问而言需要的平均时间，公式如下：
$$
存储器平均访问时间 = 命中时间 + 缺失时间 \times 缺失代价
$$
需要注意的是这一指标仅针对存储器访问指令，因此这是一个间接度量，考虑以下情况：

| 参数                               | 数据  |
| ---------------------------------- | ----- |
| 16KB指令缓存缺失数（每千条指令）   | 3.82  |
| 16KB数据缓存缺失数（每千条指令）   | 40.9  |
| 32KB统一缓存缺失数（每千条指令）   | 43.3  |
| 统一缓存数据访问额外需要时钟周期数 | 1     |
| 存储器访问中指令引用占比           | 74%   |
| 命中周期数/缺失代价                | 1/100 |
| 指令中数据传输指令占比             | 36%   |

需要复习的是，缺失数指的是对于所有指令而言产生存储器缺失的次数，而缺失率为相对于所有存储器访问产生缺失的比例。对于16KB的指令缓存，每条指令都会产生一次指令访问，缺失率为：
$$
缺失率_{指令} = \frac{3.82}{1000 \times 1} = 0.004
$$
对于16KB的数据缓存，有36%的指令会产生一次存储器访问，因此有：
$$
缺失率_{数据} = \frac{40.9 }{0.36 \times 1000} = 0.114
$$
有74%的存储器访问为指令访问，因此总体的缺失率为：
$$
缺失率_{分裂} = 0.74 \times 0.004 + 0.26 \times 0.114 = 0.0326
$$
考虑存储器平均访问时间，有：
$$
存储器平均访问时间_{分裂} = 0.74 \times (1+0.004 \times 200) + 0.26 \times (1 + 0.114\times 200) = 7.52
$$
对于32KB统一缓存而言，1000条指令一共产生1000次指令访存，其中36%的指令会产生数据访存，如下所示：
$$
缺失率_{统一} = \frac{43.3}{1000 + 1000 \times 0.36} = 0.0318
$$
对于统一缓存而言，数据访存指令会产生两种存储器访问，一次指令访问和一次数据访问，而统一缓存仅有端口，因此数据访问需要等待一个时钟周期，因此存储器平均访问时间：
$$
存储器平均访问时间_{统一} = 0.74 \times (1+0.0318 \times 200) + 0.26 \times (1 + 1 + 0.0318 \times 200) = 7.62
$$

## 对CPU性能影响

对于CPU性能而言，有以下公式：
$$
CPU执行时间=(CPU时钟周期数+存储器停顿时钟周期数) \times 时钟周期时间
$$
一般认为缓存命中时间作为CPU执行时钟周期数的一个部分，考虑一个以下参数的缓存：

| 参数                       | 数值 |
| -------------------------- | ---- |
| CPU执行周期数              | 1    |
| 缺失代价                   | 200  |
| 平均缺失率                 | 2%   |
| 每条指令的存储器引用数     | 1.5  |
| 平均缓存缺失数（千条指令） | 30   |

对于以上参数，每千条指令产生的存储访问数为$1000 \times 1.5 = 150$，存储器访问的缺失率为2%，即千条指令产生的存储器缺失数量为$150 \times 2\%=30$，与给出的平均缓存缺失数一致。使用缺失数计算CPU执行时间：
$$
CPU执行时间 = IC \times (1 + \frac{存储器停顿周期数}{IC}) \times 时钟周期 \\= IC \times (1 + \frac{停顿数}{IC} \times 缺失代价) \times 时钟周期 = IC \times (1+\frac{30}{1000} \times 200) \times 时钟周期 \\ = 7 \times IC \times 时钟周期
$$
上述分析均对于顺序存储器而言，其每次存储器缺失都会暴露为缺失代价。对于乱序处理器而言，其存储器缺失可能被乱序执行的其他指令掩盖，即有：
$$
存储器停顿周期 = 缺失数 \times (总缺失代价 - 重叠缺失延迟)
$$
对于乱序执行的CPU而言，分析比较复杂，若一个时钟周期该CPU没有提交最大可能数目的指令，则认为该CPU发生的了存储器访问缺失。

# 存储器层次结构

存储器之间的关于存储器层次结构，需要解决以下四个问题：

- 块的放置：一个块可以放在这一级的什么位置
- 块的识别：如何找到放置在这一级中的一个块
- 块的替换：在缺失时应当替换哪个块
- 块的写入：写入时发生什么

## 块的放置

首先定义**组**的概念，一个组是存储器中的一段连续空间，可以容纳多个（整数个）块。取一个存储器中组的数量为m，每个组可以容纳的块的数量为n，有以下关系：
$$
存储器容量 = m \times n \times 块大小
$$
任何来自某个地址的块只能被放置在一个特定的组中，这种方法被称为组相联，一个组中可以容纳n个块，即为n-路组相联。块首先被映射到组，组编号为：
$$
组编号 = 块地址 \% m 
$$
随后，这个块可以被放置在这个组中的任意块地址位置。即对于一个块地址为A的块而言，对应的组编号为$G = A\%m$，其可以被放置在这个编号为G的组中的任意有效的块起始地址位置。如下图所示：

![](./ch2_cache_group.png)

对于组相联，有两种特殊情况：

- 直接映射：每个块只能存储在一个固定的位置，有$存储地址=块地址 \% m$，可认为时n=1的1-组相联
- 全相联：一个块可以放置在任意位置，可认为时m=1的n-路组相联（缓存中仅有一个组）

## 块的识别

块的识别通过标签识别实现，每个存储器中的块对应一个标签，标签中包括一部分地址信息和有效性信号。对于一个块中的一个数据而言，其地址分为以下几个部分：

- 标志部分：地址的高位部分，判断块时需要比对的部分
- 索引部分：地址的中间部分，标记这个块若存在于存储器中，应当存在于哪个组中，这个部分不用于判断
- 块偏移：地址的低位部分，标记这个数据相对于块起始地址的偏移量

识别块时，首先根据索引部分查找到对应的组，再对比组内所有块的标志部分和要查找的块的标签部分是否相同，同时判断有效性。若标志部分相同且有效，则这个块为待识别的块，否则无识别的块，过程如下所示：

![](./ch2_cache_hit.png)

首先提供查找地址，根据其中的索引查找到可能保存这个块的组，随后比对组内的所有标志和有效位，当有有效位置高且标志匹配的块，则命中，查找到该块。对于要查找的数据，根据偏移量从块中获取数据。

## 块的替换

当块发生缺失且对应的组中没有空闲的位置时，需要从已有的块中选择一个丢弃，块的替换算法决定丢弃哪个块，替换算法有以下几种：

- 随机：随机选择一个块丢弃
- 最近最少使用（LRU）：丢弃掉未使用时间最久的块
- 先入先出（FIFO）：丢弃掉进入存储器最久的块

最近最少使用算法的记录比较困难，常见的替换方法为伪LRU算法，为每一个块设置一个bit。每次对一个块的访问会使这个bit置位为1，当一次访问后所有的bit均为高时，所有bit拉低，仅当前访问的块对应的bit拉高。当需要替换块时，随机从该bit为低的块中选择一个替换

## 块的写入

 块的写入和读取最大的差别在于读取操作可以“任意进行”，因为对任何空间的读取不会对该该空间中的数据产生影响，而写入操作必须“精准执行”，因为写入操作对存储空间中的数据产生影响。对于这一级存储器中任何一个块的写入会产生一致性问题，即当前级的数据与上一级的数据不同，为了解决这一问题，有两种解决方法：

- 直写：写入这一级存储的同时写入上一级存储
- 写回：仅写入这一级存储，当被写入的块被替换时写回上一级存储器

直写策略容易实现，能保证数据的一致性，这上一级存储器中的数据永远时清洁的（即一致的），缺点是时间消耗大。而写回策略延迟低，但是实现复杂。当写回上一级存储器时，往往先将块放入写入缓冲器以减小延迟。另外，当需要对一个地址进行写入时，可能这个地址对应的块不在这一级存储器中，有两种策略：

- 写入分派：首先执行命中操作，将块调入缓存，再进行写入
- 无写入分派：不将对应块调入，直接写入上一级存储器，直写策略下常常使用

## 举例：Opteron缓存

AMD的Opteron处理器缓存组织方式如下图所示

 ![](./opteron_cache.png)

进入缓存的地址位宽为40bit，该缓存的容量为64KB，块大小为64B，使用两路组相联缓存。即由上可知，组内偏移量为6bit，缓存内共$\frac{64KB}{64}=1024$个块，使用两路组相联即有$\frac{1024}{2} = 512$个组，由此组索引位宽为9bit，地址位宽40bit，因此标志位宽为$48-9-6=25$bit。

该缓存使用最少替代（LRU）策略和写回/写入分派策略，对于一次缓存访问过程，过程如下：

1. CPU给出40bit物理地址，分为标记、索引和偏移量三个部分（对应图中标号1）
2. 根据索引部分找到可能存放这个块的组，读取组中两个块中的标记部分（对应图中标号2）
3. 将两个标记与地址的标志部分比较，同时检查有效位是否为拉高：若有一个标记有效且与地址的标记相同，则缓存命中，使用二选一选择器将对应的数据数据输出；否则缓存未命中，需要进行访问低级存储器获取这个块（对应图中标志3）
4. 若缓存未命中，则根据最少替代策略选择一个块，并将这个块送入牺牲块缓冲区，再由牺牲块缓冲区写回低级存储器，同时从低级存储器调入需要访问的块（对应图中标志4）

由于这一缓存使用LRU和写回策略，因此对于每一个块，除了有效位以外，还需要设置LRU位和脏位设置标记，脏位用于表示该块是否与低级存储器中的块相同。当每次访问（无论读写）这个块时，都需要根据LRU算法对LRU位进行设置；当写一个块时，就将脏位拉高，因为只要块被写入，就认为其与低级缓存不同。

# 缓存优化

## 缺失模型

对于缓存优化，首先根据缺失类型将其分为3类：

- 强制缺失：第一次访问一个块时，这个块一定不在内存中，产生缺失成为强制缺失
- 容量缺失：缓存无法容纳所有的块，当缓存容量满后，再载入块时必然放弃原有的块，再次访问由于容量不足被放弃的块产生的缺失为容量缺失
- 冲突缺失：对于组相联结构，每个组中的块有限，当一个组满且另一个属于这个组的块被调入时，组中的某个块必然被放弃，再次访问由于块内冲突被放弃的块产生的缺失为冲突缺失

## 优化原理

优化目标为缩短存储器平均访问时间，有公式：
$$
存储器平均访问时间 = 命中时间+缺失率\times 缺失代价
$$
因此缩短存储器平均访问时间，有以下几种优化方法：

- 缩短命中时间：索引时避免地址转换、提前读取
- 降低缺失率：使用较大的块、较大的缓存和较高的关联度
- 降低缺失代价：多级缓存、使读取操作设定高于写入操作

## 基础优化方法

### 增加块大小

由于空间局域性原理（一个被用到的数据附近的数据可能被用到），增大块大小可以减少强制缺失，由此降低缺失率。但是较大的块会增加缺失代价，即一个块的尺寸变大，产生访问缺失时，需要花费更多的时钟周期从低级存储器中获取这个较大的块。因此选取块的大小需要综合考虑这两个因素。对于一个16K存储器，缺失率、缺失代价与块大小有以下表所示的关系：

| 块大小 | 缺失率 | 缺失代价                            |
| ------ | ------ | ----------------------------------- |
| 32     | 1.35%  | $80+32 \times \frac{2}{16} = 84$    |
| 64     | 1.06%  | $80 + 64 \times \frac{2}{16} = 88$  |
| 128    | 1.02%  | $80 + 128 \times \frac{2}{16} = 96$ |

缺失代价为无论块大小，都首先消耗80个时钟周期，随后每2个时钟周期载入16个数据。由存储器平均访问时间的公式，假设命中时间为1个时钟周期，有：
$$
存储器平均访问时间_{32} = 1 + 0.0135 \times 84 = 2.134 \\
存储器平均访问时间_{64} = 1 + 0.0106 \times 88 = 1.933 \\
存储器平均访问时间_{128} = 1+0.0102 \times 96 = 1.979
$$
由上，尺寸为64的块最适合该系统。选取块的大小需要考虑低级存储器的带宽，这一参数决定缺失代价相对于块大小的上升速度。对于高带宽的系统而言，可以选择较大的块，因为此时缺失代价的上升速度低于缺失率的下降速度。

### 增大缓存大小

增大缓存大小可以减小容量缺失进而降低缺失率，但对应的可能增加命中时间和硬件复杂度

### 提高组相联度

提高组相联度可以降低冲突缺失进而降低缺失率，对于组相联度有以下两条经验公式：

- 对于降低冲突缺失率而言，八路组相联的效果基本等同于全相联
- 2:1经验规律：大小为N的直接映射缓存与大小为N/2的2路组相联缓存大致具有相同的缺失率

对应的，提高组相联度会使硬件的命中部分变得复杂，提高了命中时间。

### 使用多级缓存

多级缓存降低了缺失代价，二级缓存（L2）指再一级缓存（L1）和主存储器之间的缓存。当一级缓存发生缺失时，访问二级缓存查找数据；若二级缓存缺失，则由二级缓存到主存中找到数据。使用二级缓存后有：
$$
缺失代价_{L1} = 存储器平局访问时间_{L2} = 命中时间_{L2} + 缺失率_{L2} \times 缺失代价_{L2}
$$
代入一级缓存的存储器平均访问时间公式有：
$$
存储器平局访问时间_{L1} = 命中时间_{L1} + 缺失率_{L1} \times (命中时间_{L2} + 缺失率_{L2} \times 缺失代价_{L2})
$$
由于使用了二级缓存，对缺失率的定义细化如下：

- 局部缺失率：$\frac{缓存中的产生的缺失数}{对该缓存进行存储器访问的总数}$，即对于L1缓存为$缺失率_{L1}$，对L2缓存为$缺失率_{L2}$
- 全局缺失率：$\frac{该缓存中产生的缺失数}{处理访问缓存总数}$，对于L1缓存为$缺失率_{L1}$，对L2缓存为$缺失率_{L1} \times 缺失率_{L2}$

对于二级缓存，停顿周期参数如下所示：
$$
每条指令平均存储器停顿周期 = 缺失数_{L1} \times 缺失代价_{L1} + 缺失数_{L2} \times 缺失代价_{L2}
$$
即对于一条指令而言，若产生缺失，则要么这一数据在L2缓存中，要么这一数据在L2缓存也缺失。对于第一种情况，这一指令的缺失仅计入$缺失数_{L1}$中；对于第二种情况，这一指令的缺失同时计入$缺失数_{L1}$和$缺失数_{L2}$。现在考虑一个以下参数的缓存系统：

| 参数                       | 数据 |
| -------------------------- | ---- |
| 第一级缓存缺失（千次引用） | 40   |
| 第二级缓存缺失（千次引用） | 20   |
| 平均指令存储器引用         | 1.5  |
| L1命中时间                 | 1    |
| L2命中时间                 | 10   |
| L2缺失代价                 | 200  |

有缺失率如下所示：
$$
全局缺失率_{L1} = 局部缺失率_{L1} = \frac{40}{1000} = 4\% \\
局部缺失率_{L2} = \frac{20}{40} = 50\% \\
全局缺失率_{L2} = \frac{20}{1000} = 2\%
$$
由此计算存储器平均访问时间：
$$
存储器平局访问时间 = 1 + 0.04 \times (10 + 0.5 \times 200) = 5.4个时钟周期
$$
若要计算每条指令的平均停顿时间，首先要计算缺失数：
$$
缺失数_{L1} = \frac{40}{}
$$
